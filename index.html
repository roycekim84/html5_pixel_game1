<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Orbs</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #0b0b10;
    font-family: 'Press Start 2P', 'Courier New', monospace;
    color: #e0f5e6;
  }
  body {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #frame {
    border: 4px solid #3aff85;
    box-shadow: 0 0 12px #3aff85, inset 0 0 8px #3aff85;
  }
  canvas {
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: #11161e;
  }
  .overlay {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    font-size: 14px;
    pointer-events: none;
  }
</style>
</head>
<body>
  <div style="position: relative;">
    <canvas id="frame" width="320" height="180"></canvas>
  </div>
<script>
(() => {
  // --- CONFIGURABLE CONSTANTS ---
  const WIDTH = 320;
  const HEIGHT = 180;
  const PLAYER_START_RADIUS = 12;
  const PLAYER_MIN_RADIUS = 6;
  const PLAYER_GROWTH = 2.5;
  const PLAYER_SHRINK = 3.5;
  const PLAYER_ACCEL = 220;
  const PLAYER_FRICTION = 8;
  const PLAYER_MAX_SPEED = 120;
  const DASH_MULTIPLIER = 1.9;
  const DASH_DURATION = 0.2;
  const DASH_COOLDOWN = 1.6;
  const BALL_BASE_SPEED = 35;
  const BALL_STEER = 20;
  const BALL_RADIUS_MIN = 5;
  const BALL_RADIUS_MAX = 10;
  const INITIAL_BALLS = 8;
  const TARGET_BALL_CAP = 16;
  const RESPAWN_DELAY = 0.6;
  const GRACE_TIME = 0.35;
  const LEVEL_INTERVAL = 15;
  const SHAKE_DECAY = 5;

  // --- STATE ---
  const canvas = document.getElementById('frame');
  const ctx = canvas.getContext('2d');
  const buffer = document.createElement('canvas');
  buffer.width = WIDTH;
  buffer.height = HEIGHT;
  const bctx = buffer.getContext('2d');
  bctx.imageSmoothingEnabled = false;

  let state = 'START';
  let balls = [];
  let particles = [];
  let respawnQueue = [];
  let combo = 0;
  let comboTimer = 0;
  let speedBoostTimer = 0;
  let graceTimer = 0;
  let time = 0;
  let level = 1;
  let bestTime = parseFloat(localStorage.getItem('best_orb_time') || '0');
  let shakeTime = 0;
  let shakeMag = 0;

  const keys = new Set();
  const pressed = new Set();

  const player = {
    x: WIDTH / 2,
    y: HEIGHT / 2,
    vx: 0,
    vy: 0,
    r: PLAYER_START_RADIUS,
    dashTime: 0,
    dashCooldown: 0,
  };

  // --- INPUT ---
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright','shift','r','enter'].includes(k)) {
      e.preventDefault();
    }
    keys.add(k);
    pressed.add(k);
  });
  window.addEventListener('keyup', e => {
    keys.delete(e.key.toLowerCase());
  });

  // --- HELPERS ---
  function randRange(min, max) { return Math.random() * (max - min) + min; }
  function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }
  function distanceSq(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx * dx + dy * dy; }
  function resetPlayer() {
    player.x = WIDTH / 2;
    player.y = HEIGHT / 2;
    player.vx = 0;
    player.vy = 0;
    player.r = PLAYER_START_RADIUS;
    player.dashTime = 0;
    player.dashCooldown = 0;
  }

  function resetGame() {
    balls = [];
    particles = [];
    respawnQueue = [];
    combo = 0;
    comboTimer = 0;
    speedBoostTimer = 0;
    graceTimer = 0;
    time = 0;
    level = 1;
    shakeTime = 0;
    shakeMag = 0;
    resetPlayer();
    for (let i = 0; i < INITIAL_BALLS; i++) spawnBall();
  }

  function spawnBall() {
    const type = Math.random() < 0.5 ? 'green' : 'red';
    let attempts = 0;
    let x, y;
    const r = randRange(BALL_RADIUS_MIN, BALL_RADIUS_MAX);
    do {
      x = randRange(r + 4, WIDTH - r - 4);
      y = randRange(r + 4, HEIGHT - r - 4);
      attempts++;
    } while (attempts < 30 && distanceSq(x, y, player.x, player.y) < Math.pow(player.r + r + 12, 2));
    const angle = randRange(0, Math.PI * 2);
    const speed = BALL_BASE_SPEED * randRange(0.8, 1.2);
    balls.push({
      x, y, r, type,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
    });
  }

  function scheduleRespawn() {
    respawnQueue.push(RESPAWN_DELAY);
  }

  function emitParticles(x, y, color) {
    for (let i = 0; i < 10; i++) {
      const ang = randRange(0, Math.PI * 2);
      const spd = randRange(30, 80);
      particles.push({ x, y, vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd, life: randRange(0.2, 0.5), color });
    }
  }

  function addShake(amount) {
    shakeMag = Math.min(6, shakeMag + amount);
    shakeTime = 0.2;
  }

  function handleCollisions() {
    for (let i = balls.length - 1; i >= 0; i--) {
      const b = balls[i];
      const dist2 = distanceSq(player.x, player.y, b.x, b.y);
      const rad = player.r + b.r;
      if (dist2 < rad * rad && graceTimer <= 0) {
        balls.splice(i, 1);
        scheduleRespawn();
        graceTimer = GRACE_TIME;
        if (b.type === 'green') {
          player.r += PLAYER_GROWTH;
          combo += 1;
          comboTimer = 2.5;
          speedBoostTimer = 0.8;
          emitParticles(b.x, b.y, '#5dff9b');
          addShake(0.8);
        } else {
          combo = 0;
          speedBoostTimer = 0;
          emitParticles(b.x, b.y, '#ff6d6d');
          addShake(2.2);
          player.r -= PLAYER_SHRINK;
          if (player.r <= PLAYER_MIN_RADIUS) {
            endGame();
            return;
          }
        }
      }
    }
  }

  function endGame() {
    state = 'GAMEOVER';
    if (time > bestTime) {
      bestTime = time;
      localStorage.setItem('best_orb_time', bestTime.toFixed(2));
    }
  }

  function processRespawns(dt) {
    for (let i = respawnQueue.length - 1; i >= 0; i--) {
      respawnQueue[i] -= dt;
      if (respawnQueue[i] <= 0) {
        respawnQueue.splice(i, 1);
        spawnBall();
      }
    }
  }

  function applyInput(dt) {
    const ax = (keys.has('d') || keys.has('arrowright') ? 1 : 0) - (keys.has('a') || keys.has('arrowleft') ? 1 : 0);
    const ay = (keys.has('s') || keys.has('arrowdown') ? 1 : 0) - (keys.has('w') || keys.has('arrowup') ? 1 : 0);
    const len = Math.hypot(ax, ay);
    let boost = speedBoostTimer > 0 ? 1.25 : 1;

    if (len > 0) {
      const normX = ax / len;
      const normY = ay / len;
      player.vx += normX * PLAYER_ACCEL * dt;
      player.vy += normY * PLAYER_ACCEL * dt;
    }

    // Dash
    if ((keys.has('shift') || keys.has(' ')) && player.dashCooldown <= 0 && player.dashTime <= 0) {
      player.dashTime = DASH_DURATION;
      player.dashCooldown = DASH_COOLDOWN;
      addShake(1.2);
    }

    if (player.dashTime > 0) {
      boost *= DASH_MULTIPLIER;
      player.dashTime -= dt;
    }

    if (player.dashCooldown > 0) player.dashCooldown -= dt;

    const maxSpeed = PLAYER_MAX_SPEED * (1 + 0.08 * combo) * boost;
    const speed = Math.hypot(player.vx, player.vy);
    if (speed > maxSpeed) {
      player.vx = (player.vx / speed) * maxSpeed;
      player.vy = (player.vy / speed) * maxSpeed;
    }

    // Friction
    player.vx -= player.vx * PLAYER_FRICTION * dt;
    player.vy -= player.vy * PLAYER_FRICTION * dt;

    player.x += player.vx * dt;
    player.y += player.vy * dt;

    // Bounds
    const margin = player.r;
    if (player.x < margin) { player.x = margin; player.vx = Math.abs(player.vx) * 0.5; }
    if (player.x > WIDTH - margin) { player.x = WIDTH - margin; player.vx = -Math.abs(player.vx) * 0.5; }
    if (player.y < margin) { player.y = margin; player.vy = Math.abs(player.vy) * 0.5; }
    if (player.y > HEIGHT - margin) { player.y = HEIGHT - margin; player.vy = -Math.abs(player.vy) * 0.5; }
  }

  function updateBalls(dt) {
    const speedMultiplier = 1 + time / 30 + (level - 1) * 0.1;
    for (const b of balls) {
      const steerAngle = randRange(-Math.PI, Math.PI);
      b.vx += Math.cos(steerAngle) * BALL_STEER * dt;
      b.vy += Math.sin(steerAngle) * BALL_STEER * dt;

      const speed = Math.hypot(b.vx, b.vy);
      const targetSpeed = BALL_BASE_SPEED * speedMultiplier;
      if (speed > 0) {
        const scale = clamp(targetSpeed / speed, 0, 1.2);
        b.vx *= scale;
        b.vy *= scale;
      }

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      if (b.x < b.r) { b.x = b.r; b.vx = Math.abs(b.vx); }
      if (b.x > WIDTH - b.r) { b.x = WIDTH - b.r; b.vx = -Math.abs(b.vx); }
      if (b.y < b.r) { b.y = b.r; b.vy = Math.abs(b.vy); }
      if (b.y > HEIGHT - b.r) { b.y = HEIGHT - b.r; b.vy = -Math.abs(b.vy); }
    }
  }

  function updateParticles(dt) {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.92;
      p.vy *= 0.92;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  function updateDifficulty(dt) {
    const target = Math.min(TARGET_BALL_CAP, INITIAL_BALLS + Math.floor(time / LEVEL_INTERVAL));
    if (balls.length + respawnQueue.length < target) {
      scheduleRespawn();
    }
    const newLevel = 1 + Math.floor(time / LEVEL_INTERVAL);
    if (newLevel !== level) level = newLevel;
  }

  function update(dt) {
    if (state === 'START') {
      if (pressed.has('enter')) {
        resetGame();
        state = 'PLAY';
      }
      pressed.clear();
      return;
    }

    if (state === 'GAMEOVER') {
      if (pressed.has('r') || pressed.has('enter')) {
        resetGame();
        state = 'PLAY';
      }
      pressed.clear();
      return;
    }

    // PLAY state
    time += dt;
    graceTimer = Math.max(0, graceTimer - dt);
    if (combo > 0) comboTimer = Math.max(0, comboTimer - dt);
    if (speedBoostTimer > 0) speedBoostTimer -= dt;

    applyInput(dt);
    updateBalls(dt);
    handleCollisions();
    processRespawns(dt);
    updateParticles(dt);
    updateDifficulty(dt);

    pressed.clear();
  }

  function drawBackground() {
    const g = bctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#0f1a29');
    g.addColorStop(1, '#0a111a');
    bctx.fillStyle = g;
    bctx.fillRect(0, 0, WIDTH, HEIGHT);
    for (let i = 0; i < 40; i++) {
      bctx.fillStyle = 'rgba(255,255,255,' + (Math.random() * 0.15 + 0.05) + ')';
      bctx.fillRect(Math.random() * WIDTH, Math.random() * HEIGHT, 1, 1);
    }
  }

  function drawBalls() {
    for (const b of balls) {
      bctx.fillStyle = b.type === 'green' ? '#53ff9c' : '#ff5b5b';
      bctx.beginPath();
      bctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      bctx.fill();
    }
  }

  function drawPlayer() {
    bctx.fillStyle = '#3aff85';
    bctx.beginPath();
    bctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
    bctx.fill();
    bctx.strokeStyle = '#113722';
    bctx.lineWidth = 2;
    bctx.beginPath();
    bctx.arc(player.x, player.y, player.r - 1, 0, Math.PI * 2);
    bctx.stroke();
  }

  function drawParticles() {
    for (const p of particles) {
      const alpha = clamp(p.life / 0.5, 0, 1);
      bctx.fillStyle = p.color;
      bctx.globalAlpha = alpha;
      bctx.fillRect(p.x - 1, p.y - 1, 2, 2);
      bctx.globalAlpha = 1;
    }
  }

  function drawUI() {
    bctx.fillStyle = '#e8f9e8';
    bctx.font = '8px monospace';
    bctx.textBaseline = 'top';
    const timeText = 'Time ' + time.toFixed(2) + 's';
    const sizeText = 'Size ' + player.r.toFixed(1);
    const levelText = 'Lvl ' + level;
    const comboText = combo > 1 ? 'Combo x' + combo : '';
    bctx.fillText(timeText, 6, 4);
    bctx.fillText(sizeText, 6, 14);
    bctx.fillText(levelText, WIDTH - 50, 4);
    if (comboText) bctx.fillText(comboText, WIDTH - 70, 14);
    const dashTxt = player.dashCooldown <= 0 ? 'Dash READY' : 'Dash ' + player.dashCooldown.toFixed(1);
    bctx.fillText(dashTxt, 6, HEIGHT - 14);
    const bestTxt = 'Best ' + bestTime.toFixed(2) + 's';
    bctx.fillText(bestTxt, WIDTH - 80, HEIGHT - 14);
  }

  function drawStateOverlays() {
    if (state === 'START') {
      drawCentered(['PIXEL ORB SURVIVE', 'Press Enter to Start', 'Move: WASD/Arrows | Dash: Shift', 'Collect GREEN to grow, RED shrinks you']);
    } else if (state === 'GAMEOVER') {
      drawCentered(['GAME OVER', 'Time: ' + time.toFixed(2) + 's', 'Best: ' + bestTime.toFixed(2) + 's', 'Press R or Enter to Restart']);
    }
  }

  function drawCentered(lines) {
    bctx.fillStyle = 'rgba(12,18,28,0.8)';
    bctx.fillRect(30, HEIGHT / 2 - lines.length * 12 - 6, WIDTH - 60, lines.length * 16 + 12);
    bctx.strokeStyle = '#3aff85';
    bctx.lineWidth = 2;
    bctx.strokeRect(30, HEIGHT / 2 - lines.length * 12 - 6, WIDTH - 60, lines.length * 16 + 12);
    bctx.fillStyle = '#e7fde7';
    bctx.font = '10px monospace';
    bctx.textAlign = 'center';
    lines.forEach((t, i) => {
      bctx.fillText(t, WIDTH / 2, HEIGHT / 2 - (lines.length * 8) + i * 16);
    });
    bctx.textAlign = 'left';
  }

  function render() {
    drawBackground();
    drawBalls();
    drawParticles();
    drawPlayer();
    drawUI();
    drawStateOverlays();
  }

  function blitToScreen() {
    ctx.save();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let dx = 0, dy = 0;
    if (shakeTime > 0) {
      dx = (Math.random() - 0.5) * shakeMag;
      dy = (Math.random() - 0.5) * shakeMag;
    }
    ctx.drawImage(buffer, dx, dy, WIDTH, HEIGHT, 0, 0, canvas.width, canvas.height);
    ctx.restore();
  }

  function resize() {
    const scale = Math.floor(Math.min(window.innerWidth / WIDTH, window.innerHeight / HEIGHT));
    const finalScale = Math.max(1, scale);
    canvas.style.width = WIDTH * finalScale + 'px';
    canvas.style.height = HEIGHT * finalScale + 'px';
  }
  window.addEventListener('resize', resize);
  resize();

  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    if (shakeTime > 0) {
      shakeTime -= dt * SHAKE_DECAY;
      if (shakeTime < 0) shakeTime = 0;
      shakeMag = Math.max(0, shakeMag - dt * 20);
    }
    update(dt);
    render();
    blitToScreen();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
