<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Orbs</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #0b0b10;
    font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    color: #e0f5e6;
  }
  body {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #frame {
    border: 3px solid #3aff85;
    box-shadow: 0 0 10px rgba(58,255,133,0.6), inset 0 0 6px rgba(58,255,133,0.5);
    background: #0d1118;
  }
  canvas {
    background: #0d1118;
  }
</style>
</head>
<body>
  <div id="wrapper" style="position: relative;">
    <canvas id="frame" width="320" height="180"></canvas>
  </div>
<script>
(() => {
  // === CONFIGURABLE CONSTANTS ===
  const ENABLE_GRAIN = true;
  const ENABLE_PIXEL_PARTICLES = true;
  const VIBE_INTENSITY = 0.35; // strength for vignette/grain accents
  const WIDTH = 320;
  const HEIGHT = 180;

  // Player + dash
  const PLAYER_START_RADIUS = 12;
  const PLAYER_MIN_RADIUS = 6;
  const PLAYER_GROWTH = 2.5;
  const PLAYER_SHRINK = 3.5;
  const PLAYER_ACCEL = 220;
  const PLAYER_FRICTION = 8;
  const PLAYER_MAX_SPEED = 120;
  const DASH_MULTIPLIER = 1.9;
  const DASH_DURATION = 0.2;
  const DASH_COOLDOWN = 1.6;

  // Orbs
  const BALL_BASE_SPEED = 35;
  const BALL_STEER = 20;
  const BALL_RADIUS_MIN = 5;
  const BALL_RADIUS_MAX = 10;
  const INITIAL_BALLS = 8;
  const TARGET_BALL_CAP = 16;
  const RESPAWN_DELAY = 0.6;

  // Feedback
  const GRACE_TIME = 0.35;
  const LEVEL_INTERVAL = 15;
  const SHAKE_DECAY = 5;
  const HITSTOP_GREEN = 0.04; // Timer pauses during hit stop for consistent feel.
  const HITSTOP_RED = 0.07;
  const SHAKE_GREEN = 1.2;
  const SHAKE_RED = 2.8;
  const PARTICLE_COUNT_MIN = 12;
  const PARTICLE_COUNT_MAX = 24;
  const PARTICLE_SIZE = [2, 3];

  // Power-ups
  const POWERUP_SPAWN_MIN = 12;
  const POWERUP_SPAWN_MAX = 18;
  const POWERUP_LIFETIME = 8;
  const POWERUP_MAX_ON_FIELD = 1;
  const POWERUP_RADIUS = 7;
  const SHIELD_DURATION = 8;
  const MAGNET_DURATION = 7;
  const MAGNET_RADIUS = 70;
  const MAGNET_PULL = 30;
  const SLOW_DURATION = 6;
  const SLOW_FACTOR = 0.6;

  // Hazard ring
  const RING_START_RADIUS = 260;
  const RING_SHRINK_DELAY = 10;
  const RING_SHRINK_RATE = 6;
  const RING_LEVEL_RATE = 1.4;
  const RING_MIN_RADIUS = 60;
  const RING_DAMAGE_PER_SEC = 5;

  // --- STATE ---
  const canvas = document.getElementById('frame');
  const ctx = canvas.getContext('2d');
  let scale = 1;
  let dpr = window.devicePixelRatio || 1;

  const keys = new Set();
  const pressed = new Set();

  let state = 'START';
  let balls = [];
  let particles = [];
  let respawnQueue = [];
  let powerups = [];
  let activePower = { type: null, timer: 0, charges: 0 };
  let spawnPowerTimer = randRange(POWERUP_SPAWN_MIN, POWERUP_SPAWN_MAX);

  let combo = 0;
  let comboTimer = 0;
  let speedBoostTimer = 0;
  let graceTimer = 0;
  let time = 0;
  let level = 1;
  let bestTime = parseFloat(localStorage.getItem('best_orb_time') || '0');
  let shakeTime = 0;
  let shakeMag = 0;
  let hitstop = 0;

  let ringRadius = RING_START_RADIUS;
  let ringTimer = 0;
  let ringWarning = 0;

  const noiseCanvas = document.createElement('canvas');
  noiseCanvas.width = 120;
  noiseCanvas.height = 68;
  const noiseCtx = noiseCanvas.getContext('2d');

  const player = {
    x: WIDTH / 2,
    y: HEIGHT / 2,
    vx: 0,
    vy: 0,
    r: PLAYER_START_RADIUS,
    dashTime: 0,
    dashCooldown: 0,
  };

  // --- INPUT ---
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright','shift','r','enter',' '].includes(k)) {
      e.preventDefault();
    }
    keys.add(k);
    pressed.add(k);
  });
  window.addEventListener('keyup', e => {
    keys.delete(e.key.toLowerCase());
  });

  // --- HELPERS ---
  function randRange(min, max) { return Math.random() * (max - min) + min; }
  function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }
  function distanceSq(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx * dx + dy * dy; }
  function refreshNoise() {
    if (!ENABLE_GRAIN) return;
    const w = noiseCanvas.width;
    const h = noiseCanvas.height;
    const id = noiseCtx.createImageData(w, h);
    for (let i = 0; i < id.data.length; i += 4) {
      const n = 80 + Math.random() * 90;
      id.data[i] = n;
      id.data[i + 1] = n;
      id.data[i + 2] = n;
      id.data[i + 3] = 90;
    }
    noiseCtx.putImageData(id, 0, 0);
  }

  function resetPlayer() {
    player.x = WIDTH / 2;
    player.y = HEIGHT / 2;
    player.vx = 0;
    player.vy = 0;
    player.r = PLAYER_START_RADIUS;
    player.dashTime = 0;
    player.dashCooldown = 0;
  }

  function resetGame() {
    balls = [];
    particles = [];
    respawnQueue = [];
    powerups = [];
    activePower = { type: null, timer: 0, charges: 0 };
    spawnPowerTimer = randRange(POWERUP_SPAWN_MIN, POWERUP_SPAWN_MAX);
    combo = 0;
    comboTimer = 0;
    speedBoostTimer = 0;
    graceTimer = 0;
    time = 0;
    level = 1;
    shakeTime = 0;
    shakeMag = 0;
    hitstop = 0;
    ringRadius = RING_START_RADIUS;
    ringTimer = 0;
    ringWarning = 0;
    resetPlayer();
    for (let i = 0; i < INITIAL_BALLS; i++) spawnBall();
  }

  // --- SPAWNS ---
  function spawnBall() {
    const type = Math.random() < 0.5 ? 'green' : 'red';
    let attempts = 0;
    let x, y;
    const r = randRange(BALL_RADIUS_MIN, BALL_RADIUS_MAX);
    do {
      x = randRange(r + 4, WIDTH - r - 4);
      y = randRange(r + 4, HEIGHT - r - 4);
      attempts++;
    } while (attempts < 30 && distanceSq(x, y, player.x, player.y) < Math.pow(player.r + r + 12, 2));
    const angle = randRange(0, Math.PI * 2);
    const speed = BALL_BASE_SPEED * randRange(0.8, 1.2);
    balls.push({
      x, y, r, type,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
    });
  }

  function scheduleRespawn() {
    respawnQueue.push(RESPAWN_DELAY);
  }

  function spawnPowerup() {
    if (powerups.length >= POWERUP_MAX_ON_FIELD) return;
    const kinds = ['shield', 'magnet', 'slow'];
    const type = kinds[Math.floor(Math.random() * kinds.length)];
    let x, y, attempts = 0;
    do {
      x = randRange(POWERUP_RADIUS + 6, WIDTH - POWERUP_RADIUS - 6);
      y = randRange(POWERUP_RADIUS + 6, HEIGHT - POWERUP_RADIUS - 6);
      attempts++;
    } while (attempts < 20 && distanceSq(x, y, player.x, player.y) < Math.pow(player.r + POWERUP_RADIUS + 10, 2));
    powerups.push({ x, y, r: POWERUP_RADIUS, type, life: POWERUP_LIFETIME });
  }

  // --- FX ---
  function emitParticles(x, y, color) {
    const count = Math.floor(randRange(PARTICLE_COUNT_MIN, PARTICLE_COUNT_MAX + 1));
    const size = PARTICLE_SIZE[Math.floor(Math.random() * PARTICLE_SIZE.length)];
    for (let i = 0; i < count; i++) {
      const ang = randRange(0, Math.PI * 2);
      const spd = randRange(40, 120);
      particles.push({
        x, y,
        vx: Math.cos(ang) * spd,
        vy: Math.sin(ang) * spd,
        life: randRange(0.2, 0.45),
        color,
        size
      });
    }
  }

  function addShake(amount) {
    shakeMag = Math.min(6, shakeMag + amount);
    shakeTime = 0.25;
  }

  function applyHitstop(duration) {
    hitstop = Math.max(hitstop, duration);
  }

  // --- GAME LOGIC ---
  function handleCollisions() {
    for (let i = balls.length - 1; i >= 0; i--) {
      const b = balls[i];
      const dist2 = distanceSq(player.x, player.y, b.x, b.y);
      const rad = player.r + b.r;
      if (dist2 < rad * rad && graceTimer <= 0) {
        balls.splice(i, 1);
        scheduleRespawn();
        graceTimer = GRACE_TIME;
        if (b.type === 'green') {
          player.r += PLAYER_GROWTH;
          combo += 1;
          comboTimer = 2.5;
          speedBoostTimer = 0.8;
          emitParticles(b.x, b.y, '#5dff9b');
          addShake(SHAKE_GREEN);
          applyHitstop(HITSTOP_GREEN);
        } else {
          const shielded = activePower.type === 'shield' && activePower.timer > 0 && activePower.charges > 0;
          if (shielded) {
            activePower.charges = 0;
            activePower.type = null;
            activePower.timer = 0;
            emitParticles(b.x, b.y, '#71e6ff');
            addShake(SHAKE_GREEN);
            applyHitstop(HITSTOP_GREEN);
          } else {
            combo = 0;
            speedBoostTimer = 0;
            emitParticles(b.x, b.y, '#ff6d6d');
            addShake(SHAKE_RED);
            applyHitstop(HITSTOP_RED);
            player.r -= PLAYER_SHRINK;
            if (player.r <= PLAYER_MIN_RADIUS) {
              endGame();
              return;
            }
          }
        }
      }
    }
  }

  function collectPowerups() {
    for (let i = powerups.length - 1; i >= 0; i--) {
      const p = powerups[i];
      const dist2 = distanceSq(player.x, player.y, p.x, p.y);
      if (dist2 < Math.pow(player.r + p.r, 2)) {
        powerups.splice(i, 1);
        switch (p.type) {
          case 'shield':
            activePower = { type: 'shield', timer: SHIELD_DURATION, charges: 1 };
            break;
          case 'magnet':
            activePower = { type: 'magnet', timer: MAGNET_DURATION, charges: 0 };
            break;
          case 'slow':
            activePower = { type: 'slow', timer: SLOW_DURATION, charges: 0 };
            break;
        }
        emitParticles(p.x, p.y, powerColor(p.type));
        addShake(1.0);
        applyHitstop(HITSTOP_GREEN);
      }
    }
  }

  function endGame() {
    state = 'GAMEOVER';
    if (time > bestTime) {
      bestTime = time;
      localStorage.setItem('best_orb_time', bestTime.toFixed(2));
    }
  }

  function processRespawns(dt) {
    for (let i = respawnQueue.length - 1; i >= 0; i--) {
      respawnQueue[i] -= dt;
      if (respawnQueue[i] <= 0) {
        respawnQueue.splice(i, 1);
        spawnBall();
      }
    }
  }

  function applyInput(dt) {
    const ax = (keys.has('d') || keys.has('arrowright') ? 1 : 0) - (keys.has('a') || keys.has('arrowleft') ? 1 : 0);
    const ay = (keys.has('s') || keys.has('arrowdown') ? 1 : 0) - (keys.has('w') || keys.has('arrowup') ? 1 : 0);
    const len = Math.hypot(ax, ay);
    let boost = speedBoostTimer > 0 ? 1.25 : 1;

    if (len > 0) {
      const normX = ax / len;
      const normY = ay / len;
      player.vx += normX * PLAYER_ACCEL * dt;
      player.vy += normY * PLAYER_ACCEL * dt;
    }

    if ((keys.has('shift') || keys.has(' ')) && player.dashCooldown <= 0 && player.dashTime <= 0) {
      player.dashTime = DASH_DURATION;
      player.dashCooldown = DASH_COOLDOWN;
      addShake(1.2);
    }

    if (player.dashTime > 0) {
      boost *= DASH_MULTIPLIER;
      player.dashTime -= dt;
    }

    if (player.dashCooldown > 0) player.dashCooldown -= dt;

    const maxSpeed = PLAYER_MAX_SPEED * (1 + 0.08 * combo) * boost;
    const speed = Math.hypot(player.vx, player.vy);
    if (speed > maxSpeed) {
      player.vx = (player.vx / speed) * maxSpeed;
      player.vy = (player.vy / speed) * maxSpeed;
    }

    player.vx -= player.vx * PLAYER_FRICTION * dt;
    player.vy -= player.vy * PLAYER_FRICTION * dt;

    player.x += player.vx * dt;
    player.y += player.vy * dt;

    const margin = player.r;
    if (player.x < margin) { player.x = margin; player.vx = Math.abs(player.vx) * 0.5; }
    if (player.x > WIDTH - margin) { player.x = WIDTH - margin; player.vx = -Math.abs(player.vx) * 0.5; }
    if (player.y < margin) { player.y = margin; player.vy = Math.abs(player.vy) * 0.5; }
    if (player.y > HEIGHT - margin) { player.y = HEIGHT - margin; player.vy = -Math.abs(player.vy) * 0.5; }
  }

  function updateBalls(dt) {
    const slowFactor = activePower.type === 'slow' && activePower.timer > 0 ? SLOW_FACTOR : 1;
    const speedMultiplier = (1 + time / 30 + (level - 1) * 0.1) * slowFactor;
    for (const b of balls) {
      const steerAngle = randRange(-Math.PI, Math.PI);
      b.vx += Math.cos(steerAngle) * BALL_STEER * dt;
      b.vy += Math.sin(steerAngle) * BALL_STEER * dt;

      // Magnet pull
      if (activePower.type === 'magnet' && activePower.timer > 0) {
        const dx = player.x - b.x;
        const dy = player.y - b.y;
        const d2 = dx * dx + dy * dy;
        if (d2 < MAGNET_RADIUS * MAGNET_RADIUS) {
          const dist = Math.sqrt(d2) || 1;
          const pull = MAGNET_PULL * dt;
          b.vx += (dx / dist) * pull;
          b.vy += (dy / dist) * pull;
        }
      }

      const speed = Math.hypot(b.vx, b.vy);
      const targetSpeed = BALL_BASE_SPEED * speedMultiplier;
      if (speed > 0) {
        const scale = clamp(targetSpeed / speed, 0, 1.2);
        b.vx *= scale;
        b.vy *= scale;
      }

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      if (b.x < b.r) { b.x = b.r; b.vx = Math.abs(b.vx); }
      if (b.x > WIDTH - b.r) { b.x = WIDTH - b.r; b.vx = -Math.abs(b.vx); }
      if (b.y < b.r) { b.y = b.r; b.vy = Math.abs(b.vy); }
      if (b.y > HEIGHT - b.r) { b.y = HEIGHT - b.r; b.vy = -Math.abs(b.vy); }
    }
  }

  function updateParticles(dt) {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.9;
      p.vy *= 0.9;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  function updateDifficulty() {
    const target = Math.min(TARGET_BALL_CAP, INITIAL_BALLS + Math.floor(time / LEVEL_INTERVAL));
    if (balls.length + respawnQueue.length < target) {
      scheduleRespawn();
    }
    const newLevel = 1 + Math.floor(time / LEVEL_INTERVAL);
    if (newLevel !== level) level = newLevel;
  }

  function updatePowerups(dt) {
    spawnPowerTimer -= dt;
    if (spawnPowerTimer <= 0) {
      spawnPowerup();
      spawnPowerTimer = randRange(POWERUP_SPAWN_MIN, POWERUP_SPAWN_MAX);
    }

    for (let i = powerups.length - 1; i >= 0; i--) {
      powerups[i].life -= dt;
      if (powerups[i].life <= 0) powerups.splice(i, 1);
    }

    if (activePower.type) {
      activePower.timer -= dt;
      if (activePower.timer <= 0) {
        activePower = { type: null, timer: 0, charges: 0 };
      }
    }
  }

  function updateRing(dt) {
    ringTimer += dt;
    if (ringTimer > RING_SHRINK_DELAY) {
      const shrinkRate = (RING_SHRINK_RATE + (level - 1) * RING_LEVEL_RATE);
      ringRadius = Math.max(RING_MIN_RADIUS, ringRadius - shrinkRate * dt);
    }

    const dx = player.x - WIDTH / 2;
    const dy = player.y - HEIGHT / 2;
    const dist = Math.hypot(dx, dy);
    if (dist > ringRadius - player.r * 0.5) {
      const damage = RING_DAMAGE_PER_SEC * dt;
      player.r -= damage;
      ringWarning = 0.5;
      if (player.r <= PLAYER_MIN_RADIUS) {
        endGame();
      }
    }
    if (ringWarning > 0) ringWarning -= dt;
  }

  function update(dt) {
    if (state === 'START') {
      if (pressed.has('enter')) {
        resetGame();
        state = 'PLAY';
      }
      pressed.clear();
      return;
    }

    if (state === 'GAMEOVER') {
      if (pressed.has('r') || pressed.has('enter')) {
        resetGame();
        state = 'PLAY';
      }
      pressed.clear();
      return;
    }

    // PLAY state
    time += dt;
    graceTimer = Math.max(0, graceTimer - dt);
    if (combo > 0) comboTimer = Math.max(0, comboTimer - dt);
    if (speedBoostTimer > 0) speedBoostTimer -= dt;

    applyInput(dt);
    updateBalls(dt);
    handleCollisions();
    collectPowerups();
    processRespawns(dt);
    updateParticles(dt);
    updatePowerups(dt);
    updateDifficulty();
    updateRing(dt);

    pressed.clear();
  }

  // --- DRAW ---
  function drawBackground() {
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#0f1824');
    g.addColorStop(1, '#090f18');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.strokeStyle = 'rgba(58,255,133,0.12)';
    ctx.lineWidth = 1.5;
    for (let i = 0; i < 28; i++) {
      const x = Math.random() * WIDTH;
      const y = Math.random() * HEIGHT;
      ctx.beginPath();
      ctx.moveTo(x - 1.5, y);
      ctx.lineTo(x + 1.5, y);
      ctx.stroke();
    }
  }

  function powerColor(type) {
    if (type === 'shield') return '#71e6ff';
    if (type === 'magnet') return '#c184ff';
    return '#76b7ff';
  }

  function drawRing() {
    ctx.strokeStyle = '#7df7c8';
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.arc(WIDTH / 2, HEIGHT / 2, ringRadius, 0, Math.PI * 2);
    ctx.stroke();
  }

  function drawBalls() {
    for (const b of balls) {
      ctx.fillStyle = b.type === 'green' ? '#53ff9c' : '#ff5b5b';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawPowerups() {
    for (const p of powerups) {
      ctx.fillStyle = powerColor(p.type);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#0b0b10';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  function drawPlayer() {
    ctx.fillStyle = '#3aff85';
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#113722';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r - 1, 0, Math.PI * 2);
    ctx.stroke();
    if (activePower.type === 'shield' && activePower.timer > 0 && activePower.charges > 0) {
      ctx.strokeStyle = '#71e6ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r + 3, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  function drawParticles() {
    for (const p of particles) {
      const alpha = clamp(p.life / 0.5, 0, 1);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = alpha;
      const size = ENABLE_PIXEL_PARTICLES ? (p.size || 2) : Math.max(1.5, (p.size || 2) * 0.9);
      ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
      ctx.globalAlpha = 1;
    }
  }

  function drawUI() {
    ctx.save();
    ctx.fillStyle = 'rgba(9,15,24,0.65)';
    ctx.strokeStyle = 'rgba(58,255,133,0.5)';
    ctx.lineWidth = 2;
    ctx.fillRect(4, 2, 130, 44);
    ctx.strokeRect(4, 2, 130, 44);
    ctx.fillRect(WIDTH - 110, 2, 106, 44);
    ctx.strokeRect(WIDTH - 110, 2, 106, 44);
    ctx.restore();

    ctx.fillStyle = '#e8f9e8';
    ctx.font = '11px ui-monospace, monospace';
    ctx.textBaseline = 'top';
    const timeText = 'Time ' + time.toFixed(2) + 's';
    const sizeText = 'Size ' + player.r.toFixed(1);
    const levelText = 'Lvl ' + level;
    const comboText = combo > 1 ? 'Combo x' + combo : '';
    ctx.fillText(timeText, 10, 6);
    ctx.fillText(sizeText, 10, 20);
    if (comboText) ctx.fillText(comboText, 10, 34);

    ctx.fillText(levelText, WIDTH - 98, 6);
    const dashTxt = player.dashCooldown <= 0 ? 'Dash READY' : 'Dash ' + player.dashCooldown.toFixed(1);
    ctx.fillText(dashTxt, WIDTH - 98, 20);
    const bestTxt = 'Best ' + bestTime.toFixed(2) + 's';
    ctx.fillText(bestTxt, WIDTH - 98, 34);

    if (activePower.type) {
      const timeLeft = Math.max(0, activePower.timer).toFixed(1);
      const label = activePower.type.toUpperCase() + ' ' + timeLeft + 's';
      ctx.fillStyle = powerColor(activePower.type);
      ctx.fillText(label, 10, HEIGHT - 22);
    } else {
      ctx.fillStyle = '#9fb3aa';
      ctx.fillText('Power none', 10, HEIGHT - 22);
    }

    if (ringWarning > 0) {
      ctx.fillStyle = '#ff8e8e';
      ctx.fillText('OUTSIDE ZONE!', WIDTH / 2 - 60, HEIGHT - 22);
    }
  }

  function drawStateOverlays() {
    if (state === 'START') {
      drawCentered(['PIXEL ORB SURVIVE', 'Press Enter to Start', 'Move: WASD/Arrows | Dash: Shift', 'Collect GREEN to grow, RED shrinks you']);
    } else if (state === 'GAMEOVER') {
      drawCentered(['GAME OVER', 'Time: ' + time.toFixed(2) + 's', 'Best: ' + bestTime.toFixed(2) + 's', 'Press R or Enter to Restart']);
    }
  }

  function drawCentered(lines) {
    ctx.fillStyle = 'rgba(12,18,28,0.8)';
    ctx.fillRect(30, HEIGHT / 2 - lines.length * 12 - 6, WIDTH - 60, lines.length * 16 + 12);
    ctx.strokeStyle = '#3aff85';
    ctx.lineWidth = 2;
    ctx.strokeRect(30, HEIGHT / 2 - lines.length * 12 - 6, WIDTH - 60, lines.length * 16 + 12);
    ctx.fillStyle = '#e7fde7';
    ctx.font = '12px ui-monospace, monospace';
    ctx.textAlign = 'center';
    lines.forEach((t, i) => {
      ctx.fillText(t, WIDTH / 2, HEIGHT / 2 - (lines.length * 8) + i * 16);
    });
    ctx.textAlign = 'left';
  }

  function renderScene() {
    drawBackground();
    drawRing();
    drawBalls();
    drawPowerups();
    drawParticles();
    drawPlayer();
    drawUI();
    drawStateOverlays();
  }

  function applyViewTransform(dx = 0, dy = 0) {
    const combinedScale = dpr * scale;
    ctx.setTransform(combinedScale, 0, 0, combinedScale, 0, 0);
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    if (dx !== 0 || dy !== 0) {
      ctx.translate(dx, dy);
    }
  }

  function drawVibeOverlay() {
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    if (ENABLE_GRAIN) {
      refreshNoise();
      ctx.globalAlpha = VIBE_INTENSITY * 0.45;
      ctx.drawImage(noiseCanvas, 0, 0, canvas.width, canvas.height);
      ctx.globalAlpha = 1;
    }
    const vg = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, canvas.width * 0.2, canvas.width / 2, canvas.height / 2, canvas.width * 0.65);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, `rgba(0,0,0,${0.55 * VIBE_INTENSITY})`);
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }

  function resize() {
    const winW = window.innerWidth;
    const winH = window.innerHeight;
    scale = Math.min(winW / WIDTH, winH / HEIGHT);
    const cssW = WIDTH * scale;
    const cssH = HEIGHT * scale;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    applyViewTransform();
  }
  window.addEventListener('resize', resize);
  resize();

  // --- LOOP ---
  let last = performance.now();
  function loop(now) {
    const rawDt = Math.min(0.05, (now - last) / 1000);
    last = now;
    const usedDt = hitstop > 0 ? 0 : rawDt;
    hitstop = Math.max(0, hitstop - rawDt);

    if (shakeTime > 0) {
      shakeTime -= rawDt * SHAKE_DECAY;
      if (shakeTime < 0) shakeTime = 0;
      shakeMag = Math.max(0, shakeMag - rawDt * 20);
    }

    update(usedDt);
    const dx = shakeTime > 0 ? (Math.random() - 0.5) * shakeMag : 0;
    const dy = shakeTime > 0 ? (Math.random() - 0.5) * shakeMag : 0;
    applyViewTransform(dx, dy);
    renderScene();
    drawVibeOverlay();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
